# README — Visualisations in the Packaging Performance Dashboard

This document provides a technical explanation of the code and data visualisations implemented in the `Dashboard_comparison.py` script.  
It describes:
- how the **data are prepared and passed on** to the charts,
- how each **visualisation** is built with **Altair** or **Plotly**,  
- and the **purpose of each code block** that generates a chart.  

### How to run the Dashboard

When the dashboard is launched, a sidebar appears on the left-hand side of the screen.
Use it to:
- Specify the paths to the **returns dataset, current boxes file, and optimiser script**.
- Check that each file is correctly loaded (a success message appears once detected).
- Click “Run” to execute the analysis.

The visualisations and KPIs will then update automatically based on the selected files.

---

## Part I: Methodological framework and data preparation

### 1.1 Libraries used

The project relies on a selection of Python libraries.

| Library | Main Purpose |
|----------|---------------|
| **Streamlit** | User interface and chart rendering. |
| **Altair** | 2D declarative charts (bar, bubble, pie, boxplot, histogram, scatter). |
| **Plotly** | 3D interactive visualisations. |
| **Pandas** | Data manipulation and preprocessing before plotting. |

---
### 1.2. Data processing
Before any visualisation, the raw data undergo some preparatory stages defined by key functions in the script:

- **Standardisation of dimensions (`prepare_returns`):** The dimensions of each returned item (SKU) are sorted from longest to shortest (`dim_1`, `dim_2`, `dim_3`). This standardisation ensures consistent orientation when evaluating an item's fit within a given box.
- **Box assignment logic (`assign_to_boxes`):** This function simulates the packing process. For each SKU, it iterates through the available boxes (sorted by volume) and assigns the item to the first, and therefore smallest—box that can accommodate it. 
- **KPI calculation (`kpis_calculation`):** This function calculates the performance indicators. Notably, the average void fill is calculated as a weighted average, taking into account the quantity of each SKU. This ensures that high-volume items have a proportionally greater impact on the final metric, reflecting reality.

### 1.3. Data flow and key variables
The following table describes the main pandas DataFrames created and transformed throughout the script:

| DataFrame | Description | Origin & Purpose |
|------------|--------------|------------------|
| `df_returns` | The initial dataset of returned items. | Loaded from a CSV; serves as the basis for all calculations. |
| `df_boxes_cur` | A list of the boxes currently in use. | Loaded from a CSV; represents the *Current* scenario. |
| `df_boxes_opt` |  The new set of boxes proposed by the algorithm. | Generated by the `evaluate_optimised` function (contained in the external `Optimised_boxes_solution.py` script); this module calculates the optimal set of box dimensions before being loaded into the dashboard for visualisation, and represents the *Optimised* scenario. |
| `df_current_assign` | The result of assigning each SKU to a box in the current scenario. | Output of `assign_to_boxes`; data source for the analysis of the current system. |
| `df_opt_assign` | The result of assigning each SKU to the new set of boxes. | Output of `assign_to_boxes`; data source for the analysis of the optimised system. |
| `per_box_cur` / `per_box_opt_rebuilt` | Aggregated statistics for each box (usage, average void fill). | Generated by `kpis_calculation`; used for summary charts. |
| `outliers` | A subset of SKUs that only fit into the "safety box." | Filtered from `df_opt_assign`; used for the outlier analysis. |

---

## Part II: Analysis of visualisations

This section breaks down each chart in the dashboard, explaining its objective, technical construction, and analytical value.

### 2.1. 3D Scatter Plot: SKU dimensional profile
**Objective:** To provide a three-dimensional representation of the SKU portfolio, positioning each item according to its sorted dimensions, and to capture the diversity and heterogeneity of items in terms of size and shape.  
**Data source:** `df_returns`  
**Technical implementation (Plotly):** A `Scatter3d` chart where the x, y, and z axes correspond to the sorted dimensions. The size of each point is proportional to the quantity, and its colour is also mapped to this quantity.

```python
st.subheader("SKU distribution (3D)")

items = df_returns.copy()
items["Volume_L"] = (items["sku_volume"] / 1_000_000).round(2)
items["dims_txt"] = (
    items["l"].astype(int).astype(str) + " × "
    + items["w"].astype(int).astype(str) + " × "
    + items["h"].astype(int).astype(str) + " mm")

fig_3d = go.Figure(data=[go.Scatter3d(
    x=items["dim_1"], y=items["dim_2"], z=items["dim_3"],
    mode="markers",
    marker=dict(
        size=items["quantity"] / items["quantity"].max() * 20 + 3,
        color=items["quantity"], colorscale="Turbo", showscale=True,
        colorbar=dict(title="Quantity"), line=dict(color="white", width=0.5), opacity=0.7),
    text=items.apply(lambda r: f"SKU: {r['sku_id']}<br>Qty: {r['quantity']:,}<br>Dims: {r['dims_txt']}<br>Vol: {r['Volume_L']:.2f} L", axis=1),
    hovertemplate="%{text}<extra></extra>",)])
```

### 2.2. Bubble chart: Comparison of box volumes
**Objective:** To visually compare the volume of each box between the *Current* and *Optimised* scenarios.  
**Data source:** A consolidated DataFrame (`sizes_all`).  
**Technical implementation (Altair):** A `mark_circle` chart where the x-axis represents the box volume and the y-axis separates the two scenarios.

```python
bubble = (
    alt.Chart(sizes_all)
    .mark_circle(opacity=0.75, stroke="white", strokeWidth=1)
    .encode(
        x=alt.X("Volume_L:Q", title="Volume (L)"),
        y=alt.Y("Scenario:N", title=None, sort=["Optimised", "Current"]),
        size=alt.Size("Volume_L:Q", scale=alt.Scale(range=[80, 1200])),
        colour=alt.Colour("Category:N",
                        scale=alt.Scale(domain=["Current", "Optimised", "Safety"],
                                        range=[COLOR_CURRENT, COLOR_OPTIMISED, COLOR_SAFETY])),
        tooltip=[alt.Tooltip("Scenario:N"), alt.Tooltip("box_id:N"), alt.Tooltip("Volume_L:Q")]))
```

### 2.3. Stacked bar chart: mean void fill by box
**Objective:** To compare the average void fill for each box across the two scenarios.  
**Data source:** `vf_cmp_plot`  
**Technical implementation (Altair):** A `mark_bar` chart where the x-axis represents the box rank (from smallest to largest) and the y-axis shows the mean void fill percentage.

```python
chart_vf_cmp = (
    alt.Chart(vf_cmp_plot)
    .mark_bar()
    .encode(
        x=alt.X("Rank:N", title="Box rank by volume (1 = smallest)"),
        y=alt.Y("Avg_Void_Fill_%:Q", title="Mean void fill (%)"),
        colour=alt.Colour("Scenario:N",
                        scale=alt.Scale(domain=["Current", "Optimised"],
                                        range=[COLOR_CURRENT, COLOR_OPTIMISED])),
        tooltip=[alt.Tooltip("Scenario:N"), alt.Tooltip("box_id:N"), alt.Tooltip("Avg_Void_Fill_%:Q")]))
```

### 2.4. Boxplots: Distribution of void fill
**Objective:** To display the statistical distribution of void fill percentages for each box.  
**Data source:** `boxplot_all`  
**Technical implementation (Altair):** A `mark_boxplot` chart, faceted by scenario. Each boxplot illustrates the median, quartiles, and range (min-max) of void fill for items assigned to that box.

```python
boxplot_chart = (
    alt.Chart(boxplot_all)
    .mark_boxplot(size=50, extent='min-max')
    .encode(
        x=alt.X("Box_Name:N", title="Box ID"),
        y=alt.Y("void_fill_pct:Q", title="Void Fill (%)"),
        colour=alt.Colour("Scenario:N",
                        scale=alt.Scale(domain=["Current", "Optimised"],
                                        range=[COLOR_CURRENT, COLOR_OPTIMISED])),
        column=alt.Column("Scenario:N", title=""),
        tooltip=[alt.Tooltip("selected_box:N"), alt.Tooltip("void_fill_pct:Q", aggregate="median")]))
```

### 2.5. Pie chart: Optimised box usage distribution
**Objective:** To illustrate the utilisation rate of each box in the optimised set.  
**Data source:** `pie_data`  

```python
pie = (alt.Chart(pie_data)
.mark_arc(outerRadius=120, innerRadius=40, stroke="white", strokeWidth=1)
    .encode(
        theta=alt.Theta("Usage (%):Q"),
        colour=alt.Colour("box_id:N", scale=alt.Scale(domain=domain, range=range_colors)),
        tooltip=[alt.Tooltip("box_id:N"), alt.Tooltip("Usage (%):Q")]))
text = (
    alt.Chart(pie_data)
    .mark_text(radius=90, size=11, fontWeight="bold", colour="white")
    .encode(theta=alt.Theta("Usage (%):Q"), text=alt.Text("Usage (%):Q", format=".1f")))
```

### 2.6. Histogram: outlier analysis
**Objective:** To analyse the characteristics of SKUs assigned to the "safety box."  
**Data source:** `outliers`  
- **Histogram:** A `mark_bar` chart that bins outlier SKUs by their volume.
  
```python
hist_volume = (
    alt.Chart(outliers_volumes)
    .mark_bar(colour=COLOR_SAFETY, opacity=0.85)
    .encode(
        x=alt.X("Volume_L:Q", bin=alt.Bin(maxbins=25), title="Volume (Litres)"),
        y=alt.Y("count()", title="Number of SKUs"),
        tooltip=[alt.Tooltip("count()", title="Number of SKUs"),
                 alt.Tooltip("Volume_L:Q", bin=True, title="Volume Range (L)")]))
```

---

## Conclusion

This document provides a methodological description of the visualisation components of the dashboard.

---
