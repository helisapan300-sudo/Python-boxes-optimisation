# README — Visualisations in the Packaging Performance Dashboard

This document provides a technical explanation of the code and data visualisations implemented in the `Dashboard_comparison.py` script.  
It describes:
- how the **data are prepared and passed on** to the charts,
- how each **visualisation** is built with **Altair** or **Plotly**,  
- and the **purpose of each code block** that generates a chart.  

### How to Run the Dashboard

When the dashboard is launched, a sidebar appears on the left-hand side of the screen.
Use it to:
- Specify the paths to the **returns dataset, current boxes file, and optimiser script**.
- Check that each file is correctly loaded (a success message appears once detected).
- Click “Run” to execute the analysis.

The visualisations and KPIs will then update automatically based on the selected files.

---

## Part I: Methodological Framework and Data Preparation

### 1.1 Libraries Used

The project relies on a selection of Python libraries.

| Library | Main Purpose |
|----------|---------------|
| **Streamlit** | User interface and chart rendering. |
| **Altair** | 2D declarative charts (bar, bubble, pie, boxplot, histogram, scatter). |
| **Plotly** | 3D interactive visualisations. |
| **Pandas** | Data manipulation and preprocessing before plotting. |

---
### 1.2. Data Processing Pipeline
Before any visualisation, the raw data undergo several preparatory stages defined by key functions in the script:

- **Standardisation of Dimensions (`prepare_returns`):** The dimensions of each returned item (SKU) are systematically sorted from longest to shortest (`dim_1`, `dim_2`, `dim_3`). This standardisation ensures consistent orientation when evaluating an item's fit within a given box.
- **Box Assignment Logic (`assign_to_boxes`):** This function simulates the packing process. For each SKU, it iterates through the available boxes (sorted by volume) and assigns the item to the first—and therefore smallest—box that can accommodate it. This logic is fundamental to the void fill calculation.
- **KPI Calculation (`kpis_calculation`):** This function computes the performance indicators. Notably, the average void fill is calculated as a weighted average, taking into account the quantity of each SKU. This ensures that high-volume items have a proportionally greater impact on the final metric, reflecting operational reality.

### 1.3. Data Flow and Key Variables
The following table describes the main pandas DataFrames created and transformed throughout the script:

| DataFrame | Description | Origin & Purpose |
|------------|--------------|------------------|
| `df_returns` | The initial dataset of returned items. | Loaded from a CSV; serves as the basis for all calculations. |
| `df_boxes_cur` | A list of the boxes currently in use. | Loaded from a CSV; represents the *Current* scenario. |
| `df_boxes_opt` |  The new set of boxes proposed by the algorithm. | Generated by the `evaluate_optimised` function (contained in the external `Optimised_boxes_solution.py` script); this module computes the optimal set of box dimensions before being loaded into the dashboard for visualisation, and represents the *Optimised* scenario. |
| `df_current_assign` | The result of assigning each SKU to a box in the current scenario. | Output of `assign_to_boxes`; data source for the analysis of the current system. |
| `df_opt_assign` | The result of assigning each SKU to the new set of boxes. | Output of `assign_to_boxes`; data source for the analysis of the optimised system. |
| `per_box_cur` / `per_box_opt_rebuilt` | Aggregated statistics for each box (usage, average void fill). | Generated by `kpis_calculation`; used for summary charts. |
| `outliers` | A subset of SKUs that only fit into the "safety box." | Filtered from `df_opt_assign`; used for the outlier analysis. |

---

## Part II: Analysis of Visualisations

This section breaks down each chart in the dashboard, explaining its objective, technical construction, and analytical value.

### 2.1. 3D Scatter Plot: SKU Dimensional Profile
**Objective:** To provide a three-dimensional representation of the SKU portfolio, positioning each item according to its sorted dimensions, and to capture the diversity and heterogeneity of items in terms of size and shape.  
**Data Source:** `df_returns`  
**Technical Implementation (Plotly):** A `Scatter3d` chart where the x, y, and z axes correspond to the sorted dimensions. The size of each point is proportional to the quantity, and its colour is also mapped to this quantity.

```python
st.subheader("SKU distribution (3D)")

items = df_returns.copy()
items["Volume_L"] = (items["sku_volume"] / 1_000_000).round(2)
items["dims_txt"] = (
    items["l"].astype(int).astype(str) + " × "
    + items["w"].astype(int).astype(str) + " × "
    + items["h"].astype(int).astype(str) + " mm")

fig_3d = go.Figure(data=[go.Scatter3d(
    x=items["dim_1"], y=items["dim_2"], z=items["dim_3"],
    mode="markers",
    marker=dict(
        size=items["quantity"] / items["quantity"].max() * 20 + 3,
        color=items["quantity"], colorscale="Turbo", showscale=True,
        colorbar=dict(title="Quantity"), line=dict(color="white", width=0.5), opacity=0.7),
    text=items.apply(lambda r: f"SKU: {r['sku_id']}<br>Qty: {r['quantity']:,}<br>Dims: {r['dims_txt']}<br>Vol: {r['Volume_L']:.2f} L", axis=1),
    hovertemplate="%{text}<extra></extra>",)])
```

### 2.2. Bubble Chart: Comparison of Box Volumes
**Objective:** To visually compare the volume of each box between the *Current* and *Optimised* scenarios.  
**Data Source:** A consolidated DataFrame (`sizes_all`).  
**Technical Implementation (Altair):** A `mark_circle` chart where the x-axis represents the box volume and the y-axis separates the two scenarios.

```python
bubble = (
    alt.Chart(sizes_all)
    .mark_circle(opacity=0.75, stroke="white", strokeWidth=1)
    .encode(
        x=alt.X("Volume_L:Q", title="Volume (L)"),
        y=alt.Y("Scenario:N", title=None, sort=["Optimised", "Current"]),
        size=alt.Size("Volume_L:Q", scale=alt.Scale(range=[80, 1200])),
        colour=alt.Colour("Category:N",
                        scale=alt.Scale(domain=["Current", "Optimised", "Safety"],
                                        range=[COLOR_CURRENT, COLOR_OPTIMISED, COLOR_SAFETY])),
        tooltip=[alt.Tooltip("Scenario:N"), alt.Tooltip("box_id:N"), alt.Tooltip("Volume_L:Q")]))
```

### 2.3. Stacked bar Chart: Mean Void Fill by Box
**Objective:** To compare the average void fill for each box across the two scenarios.  
**Data Source:** `vf_cmp_plot`  
**Technical Implementation (Altair):** A `mark_bar` chart where the x-axis represents the box rank (from smallest to largest) and the y-axis shows the mean void fill percentage.

```python
chart_vf_cmp = (
    alt.Chart(vf_cmp_plot)
    .mark_bar()
    .encode(
        x=alt.X("Rank:N", title="Box rank by volume (1 = smallest)"),
        y=alt.Y("Avg_Void_Fill_%:Q", title="Mean void fill (%)"),
        colour=alt.Colour("Scenario:N",
                        scale=alt.Scale(domain=["Current", "Optimised"],
                                        range=[COLOR_CURRENT, COLOR_OPTIMISED])),
        tooltip=[alt.Tooltip("Scenario:N"), alt.Tooltip("box_id:N"), alt.Tooltip("Avg_Void_Fill_%:Q")]))
```

### 2.4. Boxplots: Distribution of Void Fill
**Objective:** To display the statistical distribution of void fill percentages for each box.  
**Data Source:** `boxplot_all`  
**Technical Implementation (Altair):** A `mark_boxplot` chart, faceted by scenario. Each boxplot illustrates the median, quartiles, and range (min-max) of void fill for items assigned to that box.

```python
boxplot_chart = (
    alt.Chart(boxplot_all)
    .mark_boxplot(size=50, extent='min-max')
    .encode(
        x=alt.X("Box_Name:N", title="Box ID"),
        y=alt.Y("void_fill_pct:Q", title="Void Fill (%)"),
        colour=alt.Colour("Scenario:N",
                        scale=alt.Scale(domain=["Current", "Optimised"],
                                        range=[COLOR_CURRENT, COLOR_OPTIMISED])),
        column=alt.Column("Scenario:N", title=""),
        tooltip=[alt.Tooltip("selected_box:N"), alt.Tooltip("void_fill_pct:Q", aggregate="median")]))
```

### 2.5. Pie Chart: Optimised Box Usage
**Objective:** To illustrate the utilisation rate of each box in the optimised set.  
**Data Source:** `pie_data`  
**Technical Implementation (Altair):** A `mark_arc` chart (donut chart) where the angle of each slice is encoded by the "Usage (%)" statistic.

```python
pie = (alt.Chart(pie_data)
.mark_arc(outerRadius=120, innerRadius=40, stroke="white", strokeWidth=1)
    .encode(
        theta=alt.Theta("Usage (%):Q"),
        colour=alt.Colour("box_id:N", scale=alt.Scale(domain=domain, range=range_colors)),
        tooltip=[alt.Tooltip("box_id:N"), alt.Tooltip("Usage (%):Q")]))
text = (
    alt.Chart(pie_data)
    .mark_text(radius=90, size=11, fontWeight="bold", colour="white")
    .encode(theta=alt.Theta("Usage (%):Q"), text=alt.Text("Usage (%):Q", format=".1f")))
```

### 2.6. Histogram: Outlier Analysis
**Objective:** To analyse the characteristics of SKUs assigned to the "safety box."  
**Data Source:** `outliers`  
**Technical Implementation (Altair):**  
- **Histogram:** A `mark_bar` chart that bins outlier SKUs by their volume.
  
```python
hist_volume = (
    alt.Chart(outliers_volumes)
    .mark_bar(colour=COLOR_SAFETY, opacity=0.85)
    .encode(
        x=alt.X("Volume_L:Q", bin=alt.Bin(maxbins=25), title="Volume (Litres)"),
        y=alt.Y("count()", title="Number of SKUs"),
        tooltip=[alt.Tooltip("count()", title="Number of SKUs"),
                 alt.Tooltip("Volume_L:Q", bin=True, title="Volume Range (L)")]))
```
---

## Part III: Dashboard Integration and Structure

The final dashboard is built and rendered using Streamlit's native functions.

- **Layout:** The structure is managed by `st.columns()` to position indicators and comparative metrics side-by-side. Visual division between sections is achieved with `st.divider()`.
- **Content Display:** Section headers are created with `st.subheader()`, and explanatory text with `st.caption()` or `st.markdown()`. Key performance indicators are displayed with `st.metric()`.
- **Chart Rendering:** Altair and Plotly charts are embedded into the application using `st.altair_chart()` and `st.plotly_chart()`.

---

## Conclusion

This document provides a methodological description of the visualisation components of the dashboard.

---
